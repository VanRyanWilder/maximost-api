"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeObjectBase64Url = exports.decodeBase64 = exports.encodeBase64 = exports.encodeBase64Url = exports.decodeBase64Url = void 0;
const utf8_1 = require("./utf8");
const decodeBase64Url = (str) => {
    return (0, exports.decodeBase64)(str.replace(/_|-/g, m => ({ _: '/', '-': '+' })[m] ?? m));
};
exports.decodeBase64Url = decodeBase64Url;
const encodeBase64Url = (buf) => (0, exports.encodeBase64)(buf).replace(/\/|\+/g, m => ({ '/': '_', '+': '-' })[m] ?? m);
exports.encodeBase64Url = encodeBase64Url;
// This approach is written in MDN.
// btoa does not support utf-8 characters. So we need a little bit hack.
const encodeBase64 = (buf) => {
    const binary = String.fromCharCode(...new Uint8Array(buf));
    return btoa(binary);
};
exports.encodeBase64 = encodeBase64;
// atob does not support utf-8 characters. So we need a little bit hack.
const decodeBase64 = (str) => {
    const binary = atob(str);
    const bytes = new Uint8Array(new ArrayBuffer(binary.length));
    const half = binary.length / 2;
    for (let i = 0, j = binary.length - 1; i <= half; i++, j--) {
        bytes[i] = binary.charCodeAt(i);
        bytes[j] = binary.charCodeAt(j);
    }
    return bytes;
};
exports.decodeBase64 = decodeBase64;
const jsonUTF8Stringify = (obj) => utf8_1.utf8Encoder.encode(JSON.stringify(obj));
const encodeObjectBase64Url = (obj) => (0, exports.encodeBase64Url)(jsonUTF8Stringify(obj).buffer);
exports.encodeObjectBase64Url = encodeObjectBase64Url;
